# java基础


## String

---------------------

### 不可变类

String 对象是不可变的，对String类的操作实际上都是创建了一个全新的String对象，查看文档中的String类名如下

```java
public final class String
extends Object
implements Serializable, Comparable<String>, CharSequence
```

由于String对象是final 不可变类，因此将String传入方法时，实际传递的是引用的一个拷贝，每当传入的函数对目标引用进行各种转换如`upcase()`等，改变的是局部引用，该局部引用已经指向了一个新的对象，传入方法的应用并无改变。

---------------------

### 重载的+= 与+

String的不可变性会带来一定的效率问题，为String对象重载的"+"与“+=”就是一个例子。

参考代码`String mango = "mango";String s = "abc" + mango + "def" + 47;`该句代码的底层（汇编）操作如下：


- 对+自动创建StringBuilder对象

- 共调用4次StringBuilder 中的append()方法

- 最后调用toString()产生结果

虽然编译器可以自动优化性能，但是通过下列代码的对比，我们可以看出编译器的优化程度是有限的，下面两个方法同目的为生成一个String，方法1使用了多个String对象，方法2在代码中使用了Stringbuilder;

```java
public class WhitherStringBuilder{
    public String implicit(String[] fields){
        String result = "";
        for(int i = 0;i<fields.length;i++)
            result +=fields[i];
        return result;
    }
    public String explicit(String[]fields){
        String result = new StringBuilder();
        for(int i = 0;i<fields.length;i++)
            result.append(fields[i]);
        return result;
    }
}
```

两个方法编译器对应的操作分别如下



1.方法一每次循环中的操作如下

- 创建StringBuilder
- StringBuilder.append()
- StringBuilder.toString


2.方法2中整个函数的操作如下

- 创建StringBuilder
- 循环内append()
- 循环外toString

可以看到循环部分代码更简单，且只生成一个StringBuilder对象，更大好处是可预先制定StringBuilder的大小  ps:java1.5前使用的是StringBuffer，
java1.5后使用的是StringBuilder，
展开对比区别。

---------------------

### 无意识递归调用

案例代码如下：

```java
    public class InfiniteRecursion{
        public String toString(){
            return " InfiniteRecursion address:" + this +" /n ";
        }
        public tatic void main(String []args){
            List<InfiniteRecursion> v = new ArrayList<InfiniteRecursion>();
            System.out.println(v);
        }
    }
```

该代码的执行会报异常，调用toString的过程发生了自动类型转换，字符串后面 + 跟着的this会被尝试转换成String，因此this会被尝试调用this.toStirng形成递归调用，若仍想解决递归调用，应该用super.toString()，返回结果是this的地址。

---------------------

### String中常用的基本方法

`charAt();位置对应字符
equalsIgnoreCase();无视大小写匹配
lastIndexOf();最后出现字符
substring();
concat();字符串链接
intern();为每个唯一的字符序列生成一个且仅生成一个String引用`

---------------------

### 正则表达式的使用

java.util.regex  一个完全开放、自带的正则表达式包  
正则表达式中由于java.util.regex不支持反斜杠"/"的解读  
因此需要在真正赋值给String的时候使用双反斜杠

#### 应用1  字符串匹配

##### SimpleDemo

- (nnn)nnn-nnnn = (/d{3})/s/d{3}-/d{4}
- 5~15数字 0不能开头 [1-9]/d{4-14}
- 手机 13xxx 15xxx 18xxx 1[358]/d{9}


#### 匹配方法

1.整段字符串匹配  `Regex.matches(s);`
2. 一大段文字去匹配

`pattern.compile(Regex);`  用模式绑定正则
`Matcher matcher = pattern.matcher(s);`然后获取模式匹配器和字符

代码如下

``` Java
    BufferedReader in;
　　Pattern pattern = Pattern.compile("\\(\\d{3}\\)\\s\\d{3}-\\d{4}");
　　in = new BufferedReader(new FileReader("phone"));
　　String s;
　　while ((s = in.readLine()) != null){
　　  Matcher matcher = pattern.matcher(s);
　　  if (matcher.find())
　　      System.out.println(matcher.group());
　　}
　　in.close();
 ```

#### 应用2 字符串分割

```java

String regex=" +";//多个空格
String testString ="sdf  wer w gwedfgh";//测试字符串
String []ss = testString.split(regex);

```

#### Demo1

- 迭词如 kk `(.)\\1`
- 多个空格 `( +)`






#### 应用3 字符串替换

```Java

    String newString =oldString.replaceAll(reg,newstr);

```


#### Demo("reg","newstr")

- 叠词替换成& `"(.)\\1+","&"`
- 叠词替换成单字 `"(.)\\1+","$1"`


#### 应用4 获取

``` Java

    BufferedReader in;
　　Pattern pattern = Pattern.compile("\\(\\d{3}\\)\\s\\d{3}-\\d{4}");

　　in = new BufferedReader(new FileReader("phone"));

　　String s;

　　while ((s = in.readLine()) != null)

　　{

　　Matcher matcher = pattern.matcher(s);

　　while (matcher.find())

　　{

　　System.out.println(matcher.group());

　　}

　　}

　　in.close();

 ```

#### 综合应用


- ip地址排序"ip1 ip2 ip3 ip4 ip5"
- ip添加2个0 `replaceall("(\\d+)","00$1")`
- ip删除多余0(结果为三位ip) `replaceall("0*(\\d{3})","$1")`
- 分割 `split(" +")`
- 输出 `replaceall("0*(\\d+)","$1")`
- 邮件地址:reg="[a-zA-Z0-9_]@[a-zA-Z0-9]+\\.[a-zA-Z]"